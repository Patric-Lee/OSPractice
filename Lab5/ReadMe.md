## Raft协议工作场景及处理流程

### Raft工作原理
Raft是一个分布式系统的工作协议，目的是保证分布式系统的数据最终一致性，即：对于操作结果而言，分布式系统
各节点中数据的值是一致的。粗略地讲，Raft协议这样来实现数据一致性：

每个节点有三种状态：Leader，Follower和Candidate。

Leader向Follower发送命令，负责数据的更新；同时也会定期发送心跳讯息，以维持自己的Leader地位。
每一次数据操作都要通过Leader完成。

Follower接受Leader的指示更新数据并回复。当Follower失去与Leader联系时（即没有收到定期的心跳
讯息），如果满足一定条件，则成为Candidate并向其他所有节点发出竞选Leader的消息。

Candidate在得到过半数节点同意（即回复）的情况下成为新的Leader。

每次竞选Leader过程开启，就会产生一个新的任期。任期用一个连续的递增的整数表示。在一个任期内至多只有一个有效的Leader。这是通过
以下两点保证的：

如果原来的Leader宕机后又恢复了，但此时已经产生了新的Leader，那么旧Leader在收到新Leader信息时
比较任期，发现自己的任期较小，于是自动放弃Leader地位成为Follower。

如果有多个Candidate竞争，由于过半数才能成为Leader，因此保证了至多只有一个新Leader产生。若平票，那么
各个Candidate节点将在随机时间内重新发起投票，再次竞争。

每个节点各自维护一份数据日志。日志分为两部分：已经提交（committed）的部分和未提交的部分。Raft协议
保证已经提交的部分是已经被过半数节点写入的。通常一个数据操作是这样完成的：

客户端向系统请求操作数据，节点收到后转发给Leader；

Leader自身将该操作写入日志未提交部分，并广播给所有节点；

收到信息的节点将该操作写入日志未提交部分，并回复；

Leader收到过半数节点回复，将该操作的状态更改为已经提交，并广播给所有节点；

收到信息的节点也完成提交的工作。

值得注意的是，每个节点的数据日志必须是连续编号的，不允许有空缺，也不允许在已提交的日志之前还有未提交的
日志。

在上面的操作过程中随时可能出现Leader宕机的情况，这里不再细致讨论。

最后，Raft协议对于增减节点的问题没有特别完善的解决方案。一种可能的方法是，每次只允许增减一个节点，从而保证一个任期内仍然至多只有一个有效的
Leader。

### 工作场景举隅
Raft在etcd中得到了实现。ETCD是一个分布式的键-值存储系统，有许多工作场景。我们不妨来看ETCD中如何利用raft实现分布式锁的功能。

所谓分布式锁，就是分布式系统上的锁。最基础的分布式锁需要满足互斥的功能（即同一时间只能有一个客户端获取到锁），同时要能够被释放，不会造成最后的死锁。在etcd这样的分布式键-值存储系统中，我们
可以这样来实现分布式锁：
在存储系统中有一个单独与该锁相关的表。每个客户端在该表中创建一条记录，包含与自己相对应的key。key值最小的那个客户端获得锁。释放锁前删掉自己在表中的
记录，下一个key值最小的客户端获得锁。以此类推。

Raft协议在这里主要保证的是每个客户端创建记录和删除记录时的一致性。具体的过程如前所述，这里不再细谈。




## GlusterFS与AUFS
### GlusterFS及其特点

### GlusterFS的工作原理

## 配置GlusterFS

## 为LXC提供镜像服务
